{"version":3,"sources":["restaurant_info.js","dbhelper.js"],"names":["restaurant","map","window","initMap","fetchRestaurantFromURL","error","console","self","google","maps","Map","document","getElementById","zoom","center","latlng","scrollwheel","fillBreadcrumb","DBHelper","mapMarkerForRestaurant","callback","id","getParameterByName","fetchRestaurantById","fillRestaurantHTML","innerHTML","name","address","image","className","src","imageUrlForRestaurant","alt","imageAltText","cuisine_type","operating_hours","fillRestaurantHoursHTML","fillReviewsHTML","operatingHours","hours","key","row","createElement","day","appendChild","time","reviews","container","title","noReviews","ul","forEach","review","createReviewHTML","li","date","rating","comments","breadcrumb","url","location","href","replace","results","RegExp","exec","decodeURIComponent","dbName","storeName","API_URL","dbPromise","navigator","serviceWorker","idb","open","db","createObjectStore","keyPath","Promise","resolve","[object Object]","then","transaction","objectStore","getAll","restaurants","length","xhrForRestaurant","xhr","XMLHttpRequest","onload","status","restaurantsFromJson","JSON","parse","responseText","storeRestaurantsDB","send","store","put","fetchRestaurants","find","r","cuisine","filter","neighborhood","neighborhoods","v","i","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","undefined","photograph","Marker","position","urlForRestaurant","animation","Animation","DROP"],"mappings":"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","file":"../detail.min.js","sourcesContent":["let restaurant;\r\nvar map;\r\n\r\n/**\r\n * Initialize Google map, called from HTML.\r\n */\r\nwindow.initMap = () => {\r\n  fetchRestaurantFromURL((error, restaurant) => {\r\n    if (error) { // Got an error!\r\n      console.error(error);\r\n    } else {\r\n      self.map = new google.maps.Map(document.getElementById('map'), {\r\n        zoom: 16,\r\n        center: restaurant.latlng,\r\n        scrollwheel: false\r\n      });\r\n      fillBreadcrumb();\r\n      DBHelper.mapMarkerForRestaurant(self.restaurant, self.map);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Get current restaurant from page URL.\r\n */\r\nfetchRestaurantFromURL = (callback) => {\r\n  if (self.restaurant) { // restaurant already fetched!\r\n    callback(null, self.restaurant)\r\n    return;\r\n  }\r\n  const id = getParameterByName('id');\r\n  if (!id) { // no id found in URL\r\n    error = 'No restaurant id in URL'\r\n    callback(error, null);\r\n  } else {\r\n    DBHelper.fetchRestaurantById(id, (error, restaurant) => {\r\n      self.restaurant = restaurant;\r\n      if (!restaurant) {\r\n        console.error(error);\r\n        return;\r\n      }\r\n      fillRestaurantHTML();\r\n      callback(null, restaurant)\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Create restaurant HTML and add it to the webpage\r\n */\r\nfillRestaurantHTML = (restaurant = self.restaurant) => {\r\n  const name = document.getElementById('restaurant-name');\r\n  name.innerHTML = restaurant.name;\r\n\r\n  const address = document.getElementById('restaurant-address');\r\n  address.innerHTML = restaurant.address;\r\n\r\n  const image = document.getElementById('restaurant-img');\r\n  image.className = 'restaurant-img'\r\n  image.src = DBHelper.imageUrlForRestaurant(restaurant);\r\n  image.alt = DBHelper.imageAltText(restaurant);\r\n\r\n  const cuisine = document.getElementById('restaurant-cuisine');\r\n  cuisine.innerHTML = restaurant.cuisine_type;\r\n\r\n  // fill operating hours\r\n  if (restaurant.operating_hours) {\r\n    fillRestaurantHoursHTML();\r\n  }\r\n  // fill reviews\r\n  fillReviewsHTML();\r\n}\r\n\r\n/**\r\n * Create restaurant operating hours HTML table and add it to the webpage.\r\n */\r\nfillRestaurantHoursHTML = (operatingHours = self.restaurant.operating_hours) => {\r\n  const hours = document.getElementById('restaurant-hours');\r\n  for (let key in operatingHours) {\r\n    const row = document.createElement('tr');\r\n\r\n    const day = document.createElement('td');\r\n    day.innerHTML = key;\r\n    row.appendChild(day);\r\n\r\n    const time = document.createElement('td');\r\n    time.innerHTML = operatingHours[key];\r\n    row.appendChild(time);\r\n\r\n    hours.appendChild(row);\r\n  }\r\n}\r\n\r\n/**\r\n * Create all reviews HTML and add them to the webpage.\r\n */\r\nfillReviewsHTML = (reviews = self.restaurant.reviews) => {\r\n  const container = document.getElementById('reviews-container');\r\n  const title = document.createElement('h3');\r\n  title.innerHTML = 'Reviews';\r\n  container.appendChild(title);\r\n\r\n  if (!reviews) {\r\n    const noReviews = document.createElement('p');\r\n    noReviews.innerHTML = 'No reviews yet!';\r\n    container.appendChild(noReviews);\r\n    return;\r\n  }\r\n  const ul = document.getElementById('reviews-list');\r\n  reviews.forEach(review => {\r\n    ul.appendChild(createReviewHTML(review));\r\n  });\r\n  container.appendChild(ul);\r\n}\r\n\r\n/**\r\n * Create review HTML and add it to the webpage.\r\n */\r\ncreateReviewHTML = (review) => {\r\n  const li = document.createElement('li');\r\n  const name = document.createElement('p');\r\n  name.innerHTML = review.name;\r\n  li.appendChild(name);\r\n\r\n  const date = document.createElement('p');\r\n  date.innerHTML = review.date;\r\n  li.appendChild(date);\r\n\r\n  const rating = document.createElement('p');\r\n  rating.innerHTML = `Rating: ${review.rating}`;\r\n  li.appendChild(rating);\r\n\r\n  const comments = document.createElement('p');\r\n  comments.innerHTML = review.comments;\r\n  li.appendChild(comments);\r\n\r\n  return li;\r\n}\r\n\r\n/**\r\n * Add restaurant name to the breadcrumb navigation menu\r\n */\r\nfillBreadcrumb = (restaurant=self.restaurant) => {\r\n  const breadcrumb = document.getElementById('breadcrumb');\r\n  const li = document.createElement('li');\r\n  li.innerHTML = restaurant.name;\r\n  breadcrumb.appendChild(li);\r\n}\r\n\r\n/**\r\n * Get a parameter by name from page URL.\r\n */\r\ngetParameterByName = (name, url) => {\r\n  if (!url)\r\n    url = window.location.href;\r\n  name = name.replace(/[\\[\\]]/g, '\\\\$&');\r\n  const regex = new RegExp(`[?&]${name}(=([^&#]*)|&|#|$)`),\r\n    results = regex.exec(url);\r\n  if (!results)\r\n    return null;\r\n  if (!results[2])\r\n    return '';\r\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '));\r\n}\r\n","//name of the database name\r\nconst dbName = 'restaurants';\r\n//name of the store name with restaurants\r\nconst storeName = 'restaurants';\r\n\r\n/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n\r\n  /**\r\n   * API URL\r\n   */\r\n  static get API_URL() {\r\n    const port = 1337 // Change this to YOUR server port\r\n    //url to server with restaurant data\r\n    return `http://127.0.0.1:${port}/restaurants`;\r\n  }\r\n\r\n  /**\r\n   * Promise for indexdb db.\r\n   */\r\n  static get dbPromise() {    \r\n    //if there is no service worker available, just return\r\n    if(!navigator.serviceWorker) return Promise.resolve();\r\n    //opening db\r\n    return idb.open(dbName, 1, (db) => {\r\n      db.createObjectStore(storeName, {keyPath:'id'});\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback) {\r\n    DBHelper.dbPromise.then(db => {\r\n      //there is no db, so first fetching of data\r\n      if(!db) {\r\n        //fetch data from server\r\n        DBHelper.xhrForRestaurant(callback);\r\n      } else {\r\n        //db exists, just get data from there\r\n        const tx = db.transaction(dbName);\r\n        const store = tx.objectStore(storeName);\r\n        store.getAll().then(restaurants => {\r\n          if(!restaurants || restaurants.length === 0) {\r\n            //no restaurants available?\r\n            DBHelper.xhrForRestaurant(callback);\r\n          } else {\r\n            //we have restaurants, yay, send them through\r\n            callback(null, restaurants)\r\n          }\r\n        });\r\n      }\r\n    });    \r\n  }\r\n\r\n  /**\r\n   * Fetch data throught xmlhttprequest\r\n   */\r\n  static xhrForRestaurant(callback) {\r\n    let xhr = new XMLHttpRequest();\r\n    xhr.open('GET', DBHelper.API_URL);\r\n    xhr.onload = () => {\r\n      if (xhr.status === 200) { // Got a success response from server!\r\n        const restaurantsFromJson = JSON.parse(xhr.responseText);\r\n        //save restaurants to db\r\n        DBHelper.storeRestaurantsDB(restaurantsFromJson);\r\n        callback(null, restaurantsFromJson);\r\n      } else { // Oops!. Got an error from server.\r\n        const error = (`Request failed. Returned status of ${xhr.status}`);\r\n        callback(error, null);\r\n      }              \r\n    };\r\n    xhr.send();\r\n  }\r\n\r\n  /**\r\n   * Store all fetched restaurants in indexDB.\r\n   */\r\n  static storeRestaurantsDB(restaurants) {\r\n    DBHelper.dbPromise.then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction(dbName, \"readwrite\");\r\n      const store = tx.objectStore(storeName);\r\n      restaurants.forEach(restaurant => {\r\n        store.put(restaurant);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) { // Got the restaurant\r\n          callback(null, restaurant);\r\n        } else { // Restaurant does not exist in the database\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine, callback) {\r\n    // Fetch all restaurants  with proper error handling\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants\r\n        if (cuisine != 'all') { // filter by cuisine\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // filter by neighborhood\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n        // Remove duplicates from neighborhoods\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n        // Remove duplicates from cuisines\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`./restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant) {\r\n    if(!restaurant || restaurant.photograph === undefined) return null;\r\n    return (`/img/${restaurant.photograph}.webp`);\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n  static mapMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP}\r\n    );\r\n    return marker;\r\n  }\r\n\r\n  static imageAltText(restaurant) {\r\n    return restaurant.name + ' restaurant in ' + restaurant.neighborhood + ' offers ' + restaurant.cuisine_type + ' cuisine type';\r\n  }\r\n}"]}